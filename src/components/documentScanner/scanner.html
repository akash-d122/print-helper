<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCV Document Scanner</title>
    <script src="https://docs.opencv.org/4.5.2/opencv.js" async></script>
    <style>
        body, html { margin: 0; padding: 0; font-family: sans-serif; }
        .container { padding: 10px; }
        .status { font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <p class="status">OpenCV.js Status: <span id="status">Loading...</span></p>
    </div>
    <canvas id="outputCanvas"></canvas>

    <script>
        const statusEl = document.getElementById('status');
        
        cv.onRuntimeInitialized = () => {
            statusEl.textContent = 'Ready.';
            // Notify RN that the WebView is ready to receive an image
            window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'READY' }));
        };

        document.addEventListener('message', event => {
            try {
                const message = JSON.parse(event.data);
                if (message.type === 'PROCESS_IMAGE') {
                    processImage(message.payload.base64);
                }
            } catch (e) {
                // Not a JSON message, likely the raw base64 string from older implementation
                 processImage(event.data);
            }
        });

        function processImage(base64) {
            statusEl.textContent = 'Processing...';
            const img = new Image();
            img.onload = () => {
                try {
                    const src = cv.imread(img);
                    const processedMat = new cv.Mat();
                    
                    // 1. Grayscale and Blur
                    let gray = new cv.Mat();
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                    cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);

                    // 2. Edge Detection
                    let canny = new cv.Mat();
                    cv.Canny(gray, canny, 75, 200);

                    // 3. Find Contours
                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(canny, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

                    // 4. Find the largest contour
                    let largestArea = 0;
                    let largestContour = null;
                    for (let i = 0; i < contours.size(); ++i) {
                        let contour = contours.get(i);
                        let area = cv.contourArea(contour, false);
                        if (area > largestArea) {
                            let peri = cv.arcLength(contour, true);
                            let approx = new cv.Mat();
                            cv.approxPolyDP(contour, approx, 0.02 * peri, true);
                            if (approx.rows === 4) {
                                largestArea = area;
                                largestContour = approx;
                            } else {
                                approx.delete();
                            }
                        }
                        contour.delete();
                    }

                    if (largestContour) {
                        // 5. Apply Perspective Transform
                        const points = Array.from(largestContour.data32S).reduce((acc, val, i) => {
                            if (i % 2 === 0) acc.push({ x: val });
                            else acc[acc.length - 1].y = val;
                            return acc;
                        }, []).sort((a, b) => a.y - b.y);

                        const [pt1, pt2] = points.slice(0, 2).sort((a, b) => a.x - b.x);
                        const [pt3, pt4] = points.slice(2, 4).sort((a, b) => a.x - b.x);
                        
                        const corners = [pt1, pt2, pt4, pt3]; // top-left, top-right, bottom-right, bottom-left

                        const widthA = Math.hypot(corners[1].x - corners[0].x, corners[1].y - corners[0].y);
                        const widthB = Math.hypot(corners[2].x - corners[3].x, corners[2].y - corners[3].y);
                        const maxWidth = Math.max(widthA, widthB);

                        const heightA = Math.hypot(corners[3].x - corners[0].x, corners[3].y - corners[0].y);
                        const heightB = Math.hypot(corners[2].x - corners[1].x, corners[2].y - corners[1].y);
                        const maxHeight = Math.max(heightA, heightB);

                        const destCorners = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, maxWidth - 1, 0, maxWidth - 1, maxHeight - 1, 0, maxHeight - 1]);
                        const srcCorners = cv.matFromArray(4, 1, cv.CV_32FC2, corners.flatMap(p => [p.x, p.y]));

                        const M = cv.getPerspectiveTransform(srcCorners, destCorners);
                        cv.warpPerspective(src, processedMat, M, new cv.Size(maxWidth, maxHeight), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                        
                        // Convert warped image to grayscale for final output
                        cv.cvtColor(processedMat, processedMat, cv.COLOR_RGBA2GRAY, 0);

                        srcCorners.delete();
                        destCorners.delete();
                        M.delete();
                    } else {
                         // Fallback to grayscale if no document is found
                        cv.cvtColor(src, processedMat, cv.COLOR_RGBA2GRAY, 0);
                    }
                    
                    // Display and return result
                    const canvas = document.getElementById('outputCanvas');
                    cv.imshow(canvas, processedMat);
                    window.ReactNativeWebView.postMessage(JSON.stringify({
                        type: 'PROCESSED_IMAGE',
                        payload: { base64: canvas.toDataURL('image/png') }
                    }));

                    // Cleanup
                    src.delete();
                    processedMat.delete();
                    gray.delete();
                    canny.delete();
                    contours.delete();
                    hierarchy.delete();
                    if (largestContour) largestContour.delete();

                    statusEl.textContent = 'Done.';
                } catch (err) {
                    statusEl.textContent = 'Error: ' + err.message;
                     window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'ERROR', payload: err.message }));
                }
            };
            img.src = base64;
        }
    </script>
</body>
</html> 